{"version":3,"sources":["node_modules/fre/dist/fre.js","index.js"],"names":["App","document","querySelector","innerHTML","HTMLString","body"],"mappings":"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","file":"doc.f5381586.js","sourceRoot":"..","sourcesContent":["/**\n * by 132yse Copyright 2019-05-11\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.fre = {}));\n}(this, function (exports) { 'use strict';\n\n  const defer =\n    typeof Promise === 'function' ? cb => Promise.resolve().then(cb) : setTimeout;\n  const arrayfy = array =>\n    !array ? [] : Array.isArray(array) ? array : [array];\n  const isNew = (prev, next) => key => prev[key] !== next[key];\n  const isSame = (a, b) => a.type == b.type && a.key == b.key;\n  const hashfy = arr => {\n    let out = {};\n    let i = 0;\n    arrayfy(arr).forEach(item => {\n      let key = ((item || {}).props || {}).key;\n      key ? (out['.' + key] = item) : (out['.' + i] = item) && i++;\n    });\n    return out\n  };\n  const extend = (a, b) => {\n    for (var i in b) a[i] = b[i];\n  };\n  const megre = (a, b) => {\n    let out = {};\n    for (var i in a) out[i] = a[i];\n    for (var i in b) out[i] = b[i];\n    return out\n  };\n\n  function h (type, props) {\n    let rest = [];\n    let children = [];\n    let length = arguments.length;\n    while (length-- > 2) rest.push(arguments[length]);\n    while (rest.length) {\n      let node = rest.pop();\n      if (node && node.pop) {\n        for (length = node.length; length--;) rest.push(node[length]);\n      } else if (node === null || node === true || node === false) ; else {\n        children.push(\n          typeof node !== 'object'\n            ? { type: 'text', props: { nodeValue: node } }\n            : node\n        );\n      }\n    }\n    return {\n      type,\n      props: megre(props, { children }),\n      key: (props || {}).key || null\n    }\n  }\n\n  function updateProperty (element, name, value, newValue) {\n    if (name === 'children' || name === 'key') ; else if (name === 'style') {\n      Object.keys(newValue).forEach(key => {\n        let style = !newValue || !newValue[key] ? '' : newValue[key];\n        element[name][key] = style;\n      });\n    } else if (name[0] === 'o' && name[1] === 'n') {\n      name = name.slice(2).toLowerCase();\n      if (value) {\n        element.removeEventListener(name, value);\n      }\n      element.addEventListener(name, newValue);\n    } else {\n      element.setAttribute(name, newValue);\n    }\n  }\n  function updateElement (element, props, newProps) {\n    Object.keys(newProps)\n      .filter(isNew(props, newProps))\n      .forEach(key => {\n        if (key === 'value' || key === 'nodeValue') {\n          element[key] = newProps[key];\n        } else {\n          updateProperty(element, key, props[key], newProps[key]);\n        }\n      });\n  }\n  function createElement (fiber) {\n    const element =\n      fiber.type === 'text'\n        ? document.createTextNode('')\n        : document.createElement(fiber.type);\n    updateElement(element, [], fiber.props);\n    return element\n  }\n\n  let cursor = 0;\n  let oldInputs = [];\n  function update (key, reducer, value) {\n    const current = this ? this : getCurrentFiber();\n    value = reducer ? reducer(current.state[key], value) : value;\n    current.state[key] = value;\n    scheduleWork(current);\n  }\n  function resetCursor () {\n    cursor = 0;\n  }\n  function useState (initState) {\n    return useReducer(null, initState)\n  }\n  function useReducer (reducer, initState) {\n    let current = getCurrentFiber();\n    let key = '$' + cursor;\n    let setter = update.bind(current, key, reducer);\n    if (!current) {\n      return [initState, setter]\n    } else {\n      cursor++;\n      let state = current.state || {};\n      if (typeof state === 'object' && key in state) {\n        return [state[key], setter]\n      } else {\n        current.state[key] = initState;\n      }\n      return [initState, setter]\n    }\n  }\n  function useEffect (effect, inputs) {\n    let current = getCurrentFiber();\n    if (current) {\n      let key = '$' + cursor;\n      current.effects[key] = useMemo(effect, inputs);\n      cursor++;\n    }\n  }\n  function useMemo (create, inputs) {\n    return function () {\n      let current = getCurrentFiber();\n      if (current) {\n        let hasChaged = inputs\n          ? oldInputs.some((value, i) => inputs[i] !== value)\n          : true;\n        if (hasChaged) {\n          create();\n        }\n        oldInputs = inputs;\n      }\n    }\n  }\n  function createContext (initContext = {}) {\n    let context = initContext;\n    let setters = [];\n    const update = newContext => setters.forEach(fn => fn(newContext));\n    const subscribe = fn => setters.push(fn);\n    const unSubscribe = fn => (setters = setters.filter(f => f !== fn));\n    return { context, update, subscribe, unSubscribe }\n  }\n  function useContext (ctx) {\n    const [context, setContext] = useState(ctx.context);\n    ctx.subscribe(setContext);\n    useEffect(() => ctx.unSubscribe(setContext));\n    return [context, ctx.update]\n  }\n\n  const [HOST, HOOK, ROOT, PLACE, REPLACE, UPDATE, DELETE] = [0, 1, 2, 3, 4, 5, 6];\n  let microtasks = [];\n  let nextWork = null;\n  let pendingCommit = null;\n  let currentFiber = null;\n  function render (vdom, container) {\n    let rootFiber = {\n      tag: ROOT,\n      base: container,\n      props: { children: vdom }\n    };\n    microtasks.push(rootFiber);\n    defer(workLoop);\n  }\n  function scheduleWork (fiber) {\n    microtasks.push(fiber);\n    defer(workLoop);\n  }\n  function workLoop () {\n    if (!nextWork && microtasks.length) {\n      const update = microtasks.shift();\n      if (!update) return\n      nextWork = update;\n    }\n    while (nextWork) {\n      nextWork = performWork(nextWork);\n    }\n    if (pendingCommit) {\n      commitWork(pendingCommit);\n    }\n  }\n  function performWork (WIP) {\n    WIP.tag == HOOK ? updateHOOK(WIP) : updateHost(WIP);\n    if (WIP.child) return WIP.child\n    while (WIP) {\n      completeWork(WIP);\n      if (WIP.sibling) return WIP.sibling\n      WIP = WIP.parent;\n    }\n  }\n  function updateHost (WIP) {\n    if (!WIP.base) WIP.base = createElement(WIP);\n    let parent = WIP.parent || {};\n    WIP.insertPoint = parent.oldPoint;\n    parent.oldPoint = WIP;\n    const newChildren = WIP.props.children;\n    reconcileChildren(WIP, newChildren);\n  }\n  function updateHOOK (WIP) {\n    let instance = WIP.base;\n    if (instance == null) {\n      instance = WIP.base = createInstance(WIP);\n    }\n    WIP.props = WIP.props || {};\n    WIP.state = WIP.state || {};\n    WIP.effects = WIP.effects || {};\n    currentFiber = WIP;\n    resetCursor();\n    const newChildren = WIP.type(WIP.props);\n    reconcileChildren(WIP, newChildren);\n    currentFiber.patches = WIP.patches;\n  }\n  function fiberize (children, WIP) {\n    return (WIP.children = hashfy(children))\n  }\n  function reconcileChildren (WIP, newChildren) {\n    const oldFibers = WIP.children;\n    const newFibers = fiberize(newChildren, WIP);\n    let reused = {};\n    for (let key in oldFibers) {\n      let newFiber = newFibers[key];\n      let oldFiber = oldFibers[key];\n      if (newFiber && oldFiber.type === newFiber.type) {\n        reused[key] = oldFiber;\n        if (newFiber.key) {\n          oldFiber.key = newFiber.key;\n        }\n        continue\n      } else {\n        oldFiber.patchTag = DELETE;\n        WIP.patches.push(oldFiber);\n      }\n    }\n    let prevFiber = null;\n    let alternate = null;\n    for (let key in newFibers) {\n      let newFiber = newFibers[key];\n      let oldFiber = reused[key];\n      if (oldFiber) {\n        if (isSame(oldFiber, newFiber)) {\n          alternate = new Fiber(oldFiber, {\n            patchTag: UPDATE\n          });\n          newFiber.patchTag = UPDATE;\n          newFiber = megre(alternate, newFiber);\n          newFiber.alternate = alternate;\n          if (oldFiber.key) {\n            newFiber.patchTag = REPLACE;\n          }\n        }\n      } else {\n        newFiber = new Fiber(newFiber, {\n          patchTag: PLACE\n        });\n      }\n      newFibers[key] = newFiber;\n      newFiber.parent = WIP;\n      if (prevFiber) {\n        prevFiber.sibling = newFiber;\n      } else {\n        WIP.child = newFiber;\n      }\n      prevFiber = newFiber;\n    }\n    if (prevFiber) prevFiber.sibling = null;\n  }\n  function createInstance (fiber) {\n    const instance = new fiber.type(fiber.props);\n    instance.fiber = fiber;\n    return instance\n  }\n  function Fiber (vnode, data) {\n    this.patchTag = data.patchTag;\n    this.tag = data.tag || typeof vnode.type === 'function' ? HOOK : HOST;\n    vnode.props = vnode.props || { nodeValue: vnode.nodeValue };\n    extend(this, vnode);\n  }\n  function completeWork (fiber) {\n    if (fiber.parent) {\n      fiber.parent.patches = (fiber.parent.patches || []).concat(\n        fiber.patches || [],\n        fiber.patchTag ? [fiber] : []\n      );\n    } else {\n      pendingCommit = fiber;\n    }\n  }\n  function commitWork (WIP) {\n    WIP.patches.forEach(p => commit(p));\n    for (let key in currentFiber.effects) {\n      let effect = currentFiber.effects[key];\n      effect();\n    }\n    nextWork = pendingCommit = null;\n  }\n  let once = true;\n  function commit (fiber) {\n    if (fiber.tag == ROOT) return\n    let parentFiber = fiber.parent;\n    while (parentFiber.tag == HOOK) {\n      parentFiber = parentFiber.parent;\n    }\n    const parent = parentFiber.base;\n    let dom = fiber.base;\n    if (fiber.tag == HOOK) ; else if (fiber.patchTag == UPDATE) {\n      updateElement(fiber.base, fiber.alternate.props, fiber.props);\n    } else if (fiber.patchTag == DELETE) {\n      deleteElement(fiber, parent);\n    } else {\n      let after = once\n        ? null\n        : fiber.insertPoint\n          ? fiber.patchTag == PLACE\n            ? fiber.insertPoint.base.nextSibling\n            : fiber.insertPoint.base.nextSibling || parent.firstChild\n          : null;\n      if (after == dom) return\n      parent.insertBefore(dom, after);\n    }\n    if (dom != parent.lastChild) once = false;\n    parentFiber.patches = fiber.patches = [];\n  }\n  function deleteElement (fiber, parent) {\n    let node = fiber;\n    while (true) {\n      if (node.tag == HOOK) {\n        node = node.child;\n        continue\n      }\n      parent.removeChild(node.base);\n      node.patches = [];\n      while (node != fiber && !node.sibling) node = node.parent;\n      if (node == fiber) return\n      node = node.sibling;\n    }\n  }\n  function getCurrentFiber () {\n    return currentFiber || null\n  }\n\n  exports.createContext = createContext;\n  exports.h = h;\n  exports.render = render;\n  exports.useContext = useContext;\n  exports.useEffect = useEffect;\n  exports.useMemo = useMemo;\n  exports.useReducer = useReducer;\n  exports.useState = useState;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","import HTMLString from './README.md'\r\nimport './md.css'\r\nimport './style.css'\r\nimport { h, render, useEffect } from 'fre'\r\n\r\nfunction App () {\r\n  useEffect(() => {\r\n    document.querySelector('.wrap').innerHTML = HTMLString\r\n  })\r\n  return (\r\n    <div class='container'>\r\n      <div class='logo'>\r\n        <p align='center'>\r\n          <img\r\n            src='http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftpm5b3ihfj3096097aaj.jpg'\r\n            alt='fre logo'\r\n            width='180'\r\n          />\r\n        </p>\r\n        <h1 align='center'>Fre</h1>\r\n        <h3 align='center'>Fast 1kb React-like hooks API js library</h3>\r\n      </div>\r\n      <div class='wrap' />\r\n    </div>\r\n  )\r\n}\r\n\r\nrender(<App />, document.body)\r\n"]}